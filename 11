#include <iostream>
#include <time.h>
#include <fstream>

using namespace std;

typedef struct Champ {
	char position[20];
	char name[20];
	int hp;
	int ad;
	int armor;
	int count;
};

typedef struct Node {
	Champ data;
	Node* left;
Node* right;
};

void preset(Node** root);
void set(Node** root, Node* node);
void insert(Node** root);
void insert_BST(Node** root, Node* node);
void search(Node** root);
void search_BST(Node* root, char* name);
void print(Node* root);

int main()
{
	Node* root = NULL;
	int switch_number = 0;
	preset(&root);
	while (1)
	{
		cout << "0.종료 1.검색 2.추가 4.출력: ";
		rewind(stdin);
		cin >> switch_number;

		switch (switch_number)
		{
		case 0:
			cout << "종료합니다." << endl;
			exit(1);
		case 1:
			search(&root);
			break;
		case 2:
			insert(&root);
			break;
		case 4:
			print(root);
			break;
		default:
			cout << "잘못된 수가 입력되었습니다. 다시 입력해주세요" << endl;
			continue;
		}
	}
}

void preset(Node** root)
{
	ifstream load{ "test.txt" };
	if (load.is_open()) {
		while (!load.eof())
		{
			Node* node = new Node;
			load >> node->data.position >> node->data.name >> node->data.hp >> node->data.ad >> node->data.armor;
			set(root, node);
		}
	}
	load.close();
}

void set(Node** root, Node* node)
{
	if (*root == NULL) {
		Node* newnode = new Node;
		newnode->data = node->data;
		*root = newnode;
		newnode->right = newnode->left = NULL;
	}
	else {
		if (strcmp((*root)->data.name, node->data.name) > 0) { //root가 추가할 노드보다 클 때
			set(&(*root)->right, node);
		}
		else {
			set(&(*root)->left, node);
		}
	}
}

void insert(Node** root)
{
	Node* newnode = new Node;
	cout << "추가할 챔피언의 정보를 입력하시오" << endl;
	cout << "position: ";
	rewind(stdin);
	cin >> newnode->data.position;
	cout << "name: ";
	rewind(stdin);
	cin >> newnode->data.name;
	cout << "hp: ";
	rewind(stdin);
	cin >> newnode->data.hp;
	cout << "ad: ";
	rewind(stdin);
	cin >> newnode->data.ad;
	cout << "armor: ";
	rewind(stdin);
	cin >> newnode->data.armor;
	insert_BST(root, newnode);
}

void insert_BST(Node** root, Node* node)
{
	if ((*root)->left == NULL && (*root)->right == NULL) {
		if (strcmp((*root)->data.name, node->data.name) > 0) {
			(*root)->right = node;
			node->left = node->right = NULL;
		}
		else {
			(*root)->left = node;
			node->left = node->right = NULL;
		}
		
	}	
	else {
		if (strcmp((*root)->data.name, node->data.name) > 0) {
			insert_BST(&(*root)->right, node);
		}
			
		else if (strcmp((*root)->data.name, node->data.name) < 0)
			insert_BST(&(*root)->left, node);
		else if (strcmp((*root)->data.name, node->data.name) == 0) {
			cout << "이미 동일한 이름의 데이터가 존재합니다." << endl;
		}
	}
}

void search(Node** root)
{
	char name[20];
	cout << "검색할 챔피언의 이름을 입력하시오: ";
	rewind(stdin);
	cin >> name;
	search_BST(*root, name);
}

void search_BST(Node* root, char* name)
{
	if (root == NULL) {
		cout << "해당 챔피언은 존재하지 않습니다." << endl;
		return;
	}
	if (strcmp(root->data.name, name) == 0) {
		cout << root->data.position << " " << root->data.name << " " << root->data.hp << " " << root->data.ad << " " << root->data.armor << endl;
		return;
	}
	else {
		if (strcmp(root->data.name, name) > 0)
			search_BST(root->right, name);
		else
			search_BST(root->left, name);
	}
}

void print(Node* root)
{	
	if (root->right != NULL) {
		print(root->right);
	}
	if (root->left != NULL) {
		print(root->left);
	}	
	cout << root->data.position << " " << root->data.name << " " << root->data.hp << " " << root->data.ad << " " << root->data.armor << endl;		
}
